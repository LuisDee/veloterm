# System Architecture

> Generated by `/architect-decompose` on 2026-02-07
> Based on: conductor/product.md, conductor/tech-stack.md

---

## System Overview

VeloTerm is a cross-platform (macOS + Linux), GPU-accelerated terminal emulator built in Rust. It is a **single-process desktop application** — not a web service, microservice, or distributed system. The architecture is a modular monolith with dedicated threads for I/O, rendering, and terminal emulation, communicating via lock-free channels.

The system combines a winit event loop (keyboard/mouse/window events), wgpu GPU rendering pipeline (Metal on macOS, Vulkan/OpenGL on Linux), alacritty_terminal state machine (VT escape sequence parsing), and portable-pty (child shell process management) into a cohesive terminal emulator. Split panes and tabs are managed through a binary tree layout engine with one terminal instance per pane.

Performance is the primary architectural driver: <10ms input-to-screen latency, <100ms startup, <10MB memory per terminal instance. The architecture avoids async runtimes in favor of dedicated threads with crossbeam-channel (~20ns per send/receive).

---

## Component Map

```
┌──────────────────────────────────────────────────────────────────────┐
│                         VeloTerm Process                             │
│                                                                      │
│  ┌────────────────────────────────────────────────────────────────┐  │
│  │                    Main Thread (Event Loop)                     │  │
│  │                                                                │  │
│  │  ┌──────────┐  ┌──────────┐  ┌─────────────┐  ┌───────────┐  │  │
│  │  │  winit   │  │  Config  │  │  Pane Layout │  │  Tab Mgr  │  │  │
│  │  │  Events  │  │  (TOML)  │  │  (Bin Tree)  │  │           │  │  │
│  │  └────┬─────┘  └────┬─────┘  └──────┬──────┘  └─────┬─────┘  │  │
│  │       │              │               │               │        │  │
│  │  ┌────┴──────────────┴───────────────┴───────────────┴─────┐  │  │
│  │  │                     Input Router                         │  │  │
│  │  │  (keyboard → PTY write, mouse → selection/resize/focus)  │  │  │
│  │  └────────────────────────┬─────────────────────────────────┘  │  │
│  │                           │                                    │  │
│  │  ┌────────────────────────┴─────────────────────────────────┐  │  │
│  │  │                   GPU Renderer (wgpu)                     │  │  │
│  │  │  ┌─────────┐ ┌──────────┐ ┌────────┐ ┌───────────────┐  │  │  │
│  │  │  │  Glyph  │ │  Grid    │ │ Cursor │ │  UI Overlay   │  │  │  │
│  │  │  │  Atlas  │ │ Renderer │ │ Render │ │ (dividers,    │  │  │  │
│  │  │  │         │ │          │ │        │ │  tabs, search)│  │  │  │
│  │  │  └─────────┘ └──────────┘ └────────┘ └───────────────┘  │  │  │
│  │  └──────────────────────────────────────────────────────────┘  │  │
│  └────────────────────────────────────────────────────────────────┘  │
│                                                                      │
│  ┌──────────────────────────────── Per Pane ──────────────────────┐  │
│  │  ┌─────────────┐    crossbeam     ┌──────────────────────┐    │  │
│  │  │  PTY Reader │ ──────────────▶  │  Terminal State       │    │  │
│  │  │  Thread     │    channel       │  (alacritty_terminal) │    │  │
│  │  │  (blocking  │                  │  Grid + Scrollback    │    │  │
│  │  │   read)     │                  │  + Selection          │    │  │
│  │  └──────┬──────┘                  └──────────┬───────────┘    │  │
│  │         │                                    │                │  │
│  │    ┌────┴────┐                        ┌──────┴──────┐         │  │
│  │    │  Shell  │                        │  Grid       │         │  │
│  │    │ Process │                        │  Bridge     │         │  │
│  │    │ (bash,  │                        │  → GridCell │         │  │
│  │    │  zsh)   │                        └─────────────┘         │  │
│  │    └─────────┘                                                │  │
│  └───────────────────────────────────────────────────────────────┘  │
└──────────────────────────────────────────────────────────────────────┘
```

---

## Technology Decisions

| Decision | Choice | Rationale |
|----------|--------|-----------|
| Async runtime | None (threads + crossbeam) | 3 IO sources total; threads are simpler, lower latency, easier to debug |
| GPU abstraction | wgpu | Cross-platform Metal/Vulkan/OpenGL without conditional compilation |
| Terminal parser | alacritty_terminal | Battle-tested 15K LOC; purely a state machine, no IO coupling |
| Text shaping | cosmic-text | Higher-level than ab_glyph+rustybuzz; handles font fallback |
| PTY layer | portable-pty | Cross-platform; monomorphized away at compile time |
| Config format | TOML | Unambiguous types, no YAML footguns, fast Rust parser |
| UI overlay | egui (Phase 2+) | Immediate-mode GUI for search bar, tab bar, dividers |
| Pane layout | Binary tree | O(depth) resize, clean close semantics, recursive layout |

---

## Architecture Decision Records

### ADR-001: No Async Runtime

- **Status:** Accepted
- **Date:** 2026-02-07
- **Context:** Terminal emulators have exactly 3 IO sources: keyboard input, PTY output, and config file watching. This is not a high-concurrency problem. Async runtimes (Tokio) add ~2MB binary size, startup overhead, and complexity.
- **Decision:** Use dedicated threads with crossbeam-channel (~20ns per send/receive) for all concurrency. One reader thread per pane, main thread runs the event loop and GPU rendering.
- **Consequences:** Simpler debugging (real stack traces), lower latency, but harder to add many concurrent IO sources later. If VeloTerm ever needs 50+ concurrent connections (e.g., remote terminal multiplexing), this decision should be revisited.

### ADR-002: Single-Process Architecture

- **Status:** Accepted
- **Date:** 2026-02-07
- **Context:** Some terminal emulators use a client-server model (e.g., tmux daemon). VeloTerm provides built-in multiplexing (split panes + tabs), eliminating the need for a separate daemon.
- **Decision:** VeloTerm is a single process. Pane isolation is achieved through independent `Term` instances and dedicated PTY reader threads, not separate processes.
- **Consequences:** Simpler deployment (single binary), shared GPU resources, but a crash in one pane could affect others. Mitigated by Rust's memory safety guarantees.

### ADR-003: alacritty_terminal as Terminal Engine

- **Status:** Accepted
- **Date:** 2026-02-07
- **Context:** Building a VT100/VT220/xterm parser from scratch would take months and produce inferior results. alacritty_terminal is battle-tested with ~15K lines of focused terminal emulation code.
- **Decision:** Use alacritty_terminal as a vendored dependency with a thin wrapper layer to isolate API internals. One `Term` instance per pane.
- **Consequences:** Fast development, proven correctness, but tied to alacritty_terminal's API surface. The wrapper layer mitigates this. Kitty protocols must be added separately since alacritty_terminal doesn't include them.

### ADR-004: Graceful Shutdown Pattern

- **Status:** Accepted
- **Date:** 2026-02-07
- **Context:** VeloTerm manages multiple child shell processes, GPU resources, and potentially unsaved session state. Abrupt termination can orphan shell processes and lose session data.
- **Decision:** Implement structured shutdown: save session state → send SIGHUP to child shells → drain PTY channels → release GPU resources → exit. Handle SIGTERM and window close events identically.
- **Consequences:** Clean resource teardown, no orphan processes, session restore works reliably. Adds complexity to the shutdown path.

### ADR-005: Config Hot-Reload via File Watcher

- **Status:** Accepted
- **Date:** 2026-02-07
- **Context:** Developers frequently tweak terminal settings (fonts, colors, keybindings). Requiring a restart breaks workflow.
- **Decision:** Use `notify` crate to watch `~/.config/veloterm/veloterm.toml`. On change: parse, validate, diff against current config, and apply only changed sections. Invalid config keeps previous state and logs a warning.
- **Consequences:** Seamless config iteration. Font changes require glyph atlas rebuild (brief flicker). Some settings (e.g., GPU backend) cannot be hot-reloaded and require restart.

---

## Accepted Architecture Patterns

| Pattern | Tier | Rationale |
|---------|------|-----------|
| Graceful Shutdown | Strongly Recommended | Multiple child processes, GPU resources, session state require clean teardown |
| Config Hot-Reload | Strongly Recommended | Explicitly required in product.md; file watcher + diff + selective apply |
| Error Handling Convention | Recommended | Multiple error sources (GPU, PTY, config, font) need consistent formatting |
| Event Bus / Observer | Consider for Later | Trigger: 3+ subsystems observing terminal events |
| Plugin/Protocol Abstraction | Consider for Later | Trigger: Phase 4 Kitty protocol implementation |

---

## Deferred Pattern Triggers

| Pattern | Trigger Condition | Discovery Classification |
|---------|-------------------|--------------------------|
| Event Bus / Observer | 3+ subsystems need to react to terminal events (prompt detected, command finished, directory changed) | ARCHITECTURE_CHANGE |
| Plugin/Protocol Abstraction | Kitty Graphics or Keyboard protocol implementation begins; parser needs extension points | ARCHITECTURE_CHANGE |
